#
# Copyright (c) Microsoft. All rights reserved.
# Licensed under the MIT license. See LICENSE file in the project.
#
scalar Long

#
# An auth directive for protecting data within an organization.
#
# Required arguments on decorated schema item: 'orgId'
#
directive @orgAuth(requires: RoleType = USER) on OBJECT | FIELD_DEFINITION
directive @auth on OBJECT | FIELD_DEFINITION

# TODO: most of these queries shold be updated to @orgAuth
# TODO: queries should have a single input params variable
type Query {
	#
	# Retrieve a list of organizations
	#
	organizations(body: OrganizationsInput!): [Organization!]! @auth

	#
	# Retrieve an organization by ID
	#
	organization(body: OrganizationIdInput!): Organization @auth

	#
	# Retrieve a User by ID
	#
	user(body: UserIdInput!): User @auth

	#
	# Retrieve a contact by ID
	#
	contact(body: ContactIdInput!): Contact @auth

	#
	# Retrieve a list of contacts
	#
	contacts(body: ContactsInput!): [Contact!]! @auth

	#
	# Retrieve a single engagement by ID
	#
	engagement(body: EngagementIdInput!): Engagement @auth

	#
	# Retrieve a list of active engagements
	#
	activeEngagements(body: EngagementsInput!): [Engagement!]! @auth

	#
	# Retrieve a list of inactive engagements (i.e. Closed, Completed)
	#
	inactiveEngagements(body: EngagementsInput!): [Engagement!]! @auth

	#
	# Retrieve a list of engagements
	#
	exportData(body: OrganizationIdInput!): [Engagement!]! @auth

	#
	# Retrieve a list of services
	#
	services(body: OrganizationIdInput!): [Service!] @auth
}

type Mutation {
	#
	# Authenticate a user
	#
	authenticate(body: AuthenticationInput!): AuthenticationResponse!

	#
	# Forgot password
	#
	forgotUserPassword(body: ForgotUserPasswordInput!): ForgotUserPasswordResponse!

	#
	# Validate Forgot password token / key
	#
	validateResetUserPasswordToken(
		body: ValidateResetUserPasswordTokenInput!
	): ForgotUserPasswordResponse!

	#
	# Change password after Validate Forgot password token / key, this endpoint is unauthenticated
	#
	changeUserPassword(body: ChangeUserPasswordInput!): ForgotUserPasswordResponse!

	#
	# Assign an Engagement
	#
	assignEngagement(body: EngagementUserInput!): EngagementResponse @auth

	#
	# Create Engagement
	#
	createEngagement(body: EngagementInput!): EngagementResponse @auth

	#
	# Update Engagement
	#
	updateEngagement(body: EngagementInput!): EngagementResponse @auth

	#
	# Set engagement status
	#
	completeEngagement(body: EngagementIdInput!): EngagementResponse @auth

	#
	# Set engagement status
	#
	setEngagementStatus(body: EngagementStatusInput!): EngagementResponse @auth

	#
	# Reset user password
	#
	resetUserPassword(body: UserIdInput!): UserActionResponse @auth

	#
	# Allow user to set password
	#
	setUserPassword(body: PasswordChangeInput!): UserActionResponse @auth

	#
	# Add engagement action
	#
	addEngagementAction(body: EngagementActionInput!): EngagementResponse @auth

	#
	# Create a new user
	#
	createNewUser(body: UserInput!): UserResponse @auth

	#
	# Update user details
	#
	updateUser(body: UserInput!): UserResponse @auth

	#
	# Update user FCM Token
	#
	updateUserFCMToken(body: UserFCMInput!): VoidResponse @auth

	#
	# Mark mention as seen
	#
	markMentionSeen(body: MentionUserInput!): UserResponse @auth

	#
	# Mark mention as dismissed
	#
	markMentionDismissed(body: MentionUserInput!): UserResponse @auth

	#
	# Create new organization tag
	#
	createNewTag(body: OrgTagInput!): TagResponse @auth

	#
	# Update organization tag
	#
	updateTag(body: OrgTagInput!): TagResponse @auth

	#
	# Create a new contact
	#
	createContact(body: ContactInput!): ContactResponse @auth

	#
	# Update existing contact details
	#
	updateContact(body: ContactInput!): ContactResponse @auth

	#
	# Create a new Service
	#
	createService(body: ServiceInput!): ServiceResponse @auth

	#
	# Update a Service
	#
	updateService(body: ServiceInput!): ServiceResponse @auth

	#
	# Create a new Service Answers
	#
	createServiceAnswers(body: ServiceAnswerInput!): ServiceResponse @auth
}

type Subscription {
	#
	# Subscribe to user notificaitons
	#
	subscribeToMentions(body: UserIdInput!): MentionSubscriptionResponse

	#
	# Subscribe to engagement updates
	#
	engagementUpdate(body: OrganizationIdInput!): EngagementResponse
}

#
# Mention Subscription Response
#
type MentionSubscriptionResponse {
	#
	# The user that has been authenticated; possibly null
	#
	mention: Mention

	#
	# If returned from an update the update may include the type of update (CREATE)
	#
	action: String

	#
	# An error or status message regarding the authentication attempt
	#
	message: String!

	#
	# Status code response
	#
	statusCode: Int
}

enum StatusType {
	SUCCESS
	FAILED
}

#
# Used for mutations that do not return data
#
type VoidResponse {
	#
	# An error or status message regarding the attempted request
	#
	message: String!

	#
	# Response status
	#
	status: StatusType!
}
#
# General response type for user related actions
#
type UserActionResponse {
	#
	# The user that has been authenticated; possibly null
	#
	user: User

	#
	# An error or status message regarding the authentication attempt
	#
	message: String!

	#
	# Response status
	#
	status: StatusType!
}

#
# An Engagement Response
#
type EngagementResponse {
	#
	# The user that has been authenticated; possibly null
	#
	engagement: Engagement

	#
	# If returned from an update the update may include the type of update (CREATE, UPDATE, DELETE)
	#
	action: String

	#
	# An error or status message regarding the authentication attempt
	#
	message: String!

	#
	# Response status
	#
	status: StatusType!
}

#
# An Authentication Response
#
type AuthenticationResponse {
	#
	# The user that has been authenticated; possibly null
	#
	user: User

	#
	# An error or status message regarding the authentication attempt
	#
	message: String

	#
	# The user access token
	#
	accessToken: String

	#
	# Response status
	#
	status: StatusType!
}

#
# A Community-Based Organization
#
type Organization {
	#
	# A unique identifier for the organization
	#
	id: String!

	#
	# The organization Name
	#
	name: String!

	#
	# A brief description of the organization and its mission
	#
	description: String!

	#
	# Users working with the organization
	#
	# users: [User!]! @orgAuth(requires: USER)
	users: [User!]!

	#
	# Contact working with the organization
	#
	# contacts: [Contact!]! @orgAuth(requires: USER)
	contacts: [Contact!]!

	#
	# Tags available to the organization
	#
	tags: [Tag!]
}

#
# List of possible groupings of tags
#
enum TagCategory {
	SDOH
	PROGRAM
	GRANT
	OTHER
	ALL
}

#
# A label to group engagements and actions
#
type Tag {
	#
	# A unique id for the tag
	#
	id: String!

	#
	# An object containing translated labels for the tag
	#
	label: String!

	#
	# An object containing description for the tag
	#
	description: String

	#
	# A string identifying the categoy of the tag
	#
	category: String

	#
	# Id of the org that the tag was created in
	#
	orgId: String

	#
	# An object containing usage counts for the Tag
	#
	usageCount: TagUsageCount
}

type TagUsageCount {
	engagement: Int
	actions: Int
}

#
# Create engagement input
#
input EngagementInput {
	#
	# ID of the engagement request
	#
	engagementId: String
	#
	# ID of the org containing the engagement
	#
	orgId: String!

	#
	# ID of the contact who the engagement is being made for
	#
	contactIds: [String!]!

	#
	# Title of engagement request
	#
	title: String!

	#
	# Description of engagement request
	#
	description: String!

	#
	# Scheduled duration of the request
	#
	duration: String

	#
	# Optional id of assigned specialist to the engagement
	#
	userId: String

	#
	# Optional tags on the engagement
	#
	tags: [String!]
}

#
# A label to group engagements and actions
#
input TagInput {
	#
	# A unique id for the tag
	#
	id: String

	#
	# A string containing translated labels for the tag
	#
	label: String

	#
	# A string containing description for the tag
	#
	description: String

	#
	# A string containing category for the tag
	#
	category: String
}

type TagResponse {
	tag: Tag

	message: String
	#
	# Response status
	#
	status: StatusType!
}

#
# An object that contains translations of a string
#
# type TranslateString {
#	en_us: String
#	ko_kr: String
#	vi_vn: String
#	zh_cn: String
#	es_us: String
#	de_de: String
#	es_es: String
#	fi_fi: String
#	fr_fr: String
#	he_il: String
#	it_it: String
#	ja_jp: String
#	pt_pt: String
#	sv_se: String
#	th_th: String
# }

#
# A specialist who can provide services for clients of a CBO
#
type User {
	oid: ID
	#
	# A unique identifier for the specialist
	#
	id: String!

	#
	# A name for a person
	#
	name: Name!

	#
	# A user name for a person
	#
	userName: String!

	#
	# The roles this user has in the system
	#
	roles: [Role!]!

	#
	# The description of this user has in the system
	#
	description: String

	#
	# Additional information this user has in the system
	#
	additionalInfo: String

	#
	# The address of this user has in the system
	#
	address: Address

	#
	# The user email
	#
	email: String

	#
	# The user phone
	#
	phone: String

	#
	# Number of engagements for user, null if not available
	#
	engagementCounts: EngagementCounts

	#
	# Mentions of this user in engagments
	#

	mentions: [Mention!]!

	#
	# Forgot password token
	#
	forgotPasswordToken: String
}

#
# Basic class to model @mentions
#

type Mention {
	engagement: Engagement
	createdAt: String!
	createdBy: User
	message: String
	seen: Boolean!
	dismissed: Boolean!
	# TODO: add these fields to mentions
	# user: User!
	# message: String
	# type: 'ASSIGNED' | 'TAGGED'
}

type EngagementCounts {
	active: Int
	closed: Int
}

input UserFCMInput {
	#
	# FCM token used for push notifications
	#
	fcmToken: String
}

input UserInput {
	#
	# ID field for the user, incase this is for udpating existing user
	#
	id: String

	#
	# The first name for a person
	#
	first: String!

	#
	# The middle name for a person
	#
	middle: String

	#
	# The last name for a person
	#
	last: String!

	#
	# The username for a person
	#
	userName: String!

	#
	# The roles this user has in the system
	#
	roles: [RoleTypeInput!]

	#
	# The user email
	#
	email: String!

	#
	# The user phone
	#
	phone: String

	#
	# The user address
	#
	address: AddressInput

	#
	# The user basic description / bio
	#
	description: String

	#
	# The user additional info / trainings / achievements
	#
	additionalInfo: String

	#
	# FCM token used for push notifications
	#
	fcmToken: String
}

input AddressInput {
	#
	# Street address
	#
	street: String

	#
	# Street address line 2
	#
	unit: String

	#
	# City
	#
	city: String

	#
	# State
	#
	state: String

	#
	# Zip code
	#
	zip: String
}

input RoleTypeInput {
	roleType: RoleType!
	orgId: String!
}

type UserResponse {
	user: User
	message: String
	#
	# Response status
	#
	status: StatusType!
}

type Role {
	#
	# The kind of role the user has
	#
	roleType: RoleType!

	#
	# The organization the role relates to
	#
	orgId: String!
}

enum RoleType {
	USER
	ADMIN
	VIEWER
}

type Address {
	#
	# Street address
	#
	street: String!

	#
	# Street address line 2
	#
	unit: String

	#
	# City
	#
	city: String

	#
	# State
	#
	state: String

	#
	# The organization the role relates to
	#
	zip: String!
}

#
# A person coming into the system who is in need of assistance or resources
#
type Contact {
	#
	# A unique identifier for a contact
	#
	id: String!

	#
	# The contact name
	#
	name: Name!

	#
	# The contact email
	#
	email: String

	#
	# The contact phone
	#
	phone: String

	#
	# The contact address
	#
	address: Address

	#
	# The date of birth
	#
	dateOfBirth: String

	#
	# Engagements this contact has made with Orgs
	#
	engagements(orgId: String): [Engagement!]!

	#
	# Contact tags
	#
	tags: [Tag!]

	#
	# Demographics of the contact
	#
	demographics: Demographics
}

type Demographics {
	gender: String
	ethnicity: String
	race: String
	preferredContactMethod: String
	preferredLanguage: String
	preferredLanguageOther: String
	preferredContactTime: String
}

input DemographicsInput {
	gender: String
	ethnicity: String
	race: String
	preferredContactMethod: String
	preferredLanguage: String
	preferredLanguageOther: String
	preferredContactTime: String
}

input ContactInput {
	#
	# A unique identifier for a contact
	#
	id: String

	#
	# A unique identifier for the organization where a contact belongs
	#
	orgId: String!

	#
	# The first name for a person
	#
	first: String!

	#
	# The middle name for a person
	#
	middle: String

	#
	# The last name for a person
	#
	last: String!

	#
	# The date of birth
	#
	dateOfBirth: String

	#
	# The contact email
	#
	email: String

	#
	# The contact phone
	#
	phone: String

	#
	# The contact address
	#
	address: AddressInput

	#
	# the contact tags
	#
	tags: [String!]

	#
	# The contact demographics
	#
	demographics: DemographicsInput
}

type ContactResponse {
	contact: Contact
	message: String
	#
	# Response status
	#
	status: StatusType!
}

#
# Engagement Status
#
enum EngagementStatus {
	NOT_STARTED
	OPEN
	CLOSED
	PENDING
	ASSIGNED
	IN_PROGRESS
	COMPLETED
}

#
# A contact's engagement with a CBO
#
type Engagement {
	#
	# ID of the engagement
	#
	id: String!

	#
	# The ID of the organization being engaged
	#
	orgId: String!

	#
	# The assigned specialist. Undefined if not the engagement is not assigned
	#
	user: User

	#
	# The start date of the engagement
	#
	startDate: String!

	#
	# The end date of the engagement
	#
	endDate: String

	#
	# Engagement Actions
	#
	actions: [Action!]!

	#
	# Engagement Status
	#
	status: EngagementStatus!

	#
	# Engagement Contacts
	#
	contacts: [Contact!]!

	#
	# Engagement Title
	#
	title: String!

	#
	# Engagement Description
	#
	description: String

	#
	# Tags applied to the engagement
	#
	tags: [Tag!]!
}

#
# Input for adding an action
#
input ActionInput {
	#
	# The id of the user engaging the contact
	#
	userId: String!

	#
	# The id of the organization engaging the contact
	#
	orgId: String!

	#
	# A comment entered by the specialist
	#
	comment: String!

	#
	# Tagged user to be notified of action
	#
	taggedUserId: String

	#
	# Tags applied to the action
	#
	tags: [String!]
}

type Action {
	user: User!

	#
	# The id of the organization engaging the contact
	#
	orgId: String!

	#
	# The date the action was taken
	#
	date: String!

	#
	# A comment entered by the specialist
	#
	comment: String

	#
	# Tagged user to be notified of action
	#
	taggedUser: User

	#
	# Tags applied to the action
	#
	tags: [Tag!]!
}

#
# A name for a person
#
type Name {
	#
	# A person's first name
	#
	first: String!
	#
	# A person's last name
	#
	last: String!
	#
	# A person's middle name
	#
	middle: String
}

input OrganizationsInput {
	offset: Int
	limit: Int
}

input OrganizationIdInput {
	orgId: String!
}

input UserIdInput {
	userId: String!
}

input ContactIdInput {
	contactId: String!
}

input ContactsInput {
	orgId: String!
	offset: Int
	limit: Int
}

input EngagementIdInput {
	engId: String!
}

input EngagementsInput {
	orgId: String!
	offset: Int
	limit: Int
	userId: String
	exclude_userId: Boolean
}

input AuthenticationInput {
	username: String!
	password: String!
}

input EngagementUserInput {
	engId: String!
	userId: String!
}

input MentionUserInput {
	engId: String!
	userId: String!
	createdAt: String!
	markAll: Boolean
	dismissAll: Boolean
}

input EngagementStatusInput {
	engId: String!
	status: EngagementStatus!
}

input PasswordChangeInput {
	oldPassword: String!
	newPassword: String!
}

input EngagementActionInput {
	engId: String!
	action: ActionInput!
}

input OrgTagInput {
	orgId: String
	tag: TagInput!
}

input ForgotUserPasswordInput {
	email: String!
}

input ValidateResetUserPasswordTokenInput {
	email: String!
	resetToken: String!
}

input ChangeUserPasswordInput {
	email: String!
	newPassword: String!
}

type ForgotUserPasswordResponse {
	status: StatusType!
	message: String
}

type ServiceCustomField {
	fieldName: String!
	fieldType: String!
	fieldRequirements: String!
	fieldValue: [String!]!
}

enum ServiceStatus {
	ACTIVE
	INACTIVE
}

type ServiceSingleAnswerField {
	label: String!
	value: String!
}

input ServiceSingleAnswerFieldInput {
	label: String!
	value: String!
}

type ServiceMultiAnswerField {
	label: String!
	value: [String!]!
}

input ServiceMultiAnswerFieldInput {
	label: String!
	value: [String!]!
}

type ServiceFieldAnswer {
	singleText: [ServiceSingleAnswerField!]
	multilineText: [ServiceSingleAnswerField!]
	date: [ServiceSingleAnswerField!]
	number: [ServiceSingleAnswerField!]
	singleChoice: [ServiceSingleAnswerField!]

	# Multiple text fields
	multiText: [ServiceMultiAnswerField!]
	# Multiple choice fields (checkbox)
	multiChoice: [ServiceMultiAnswerField!]
}

input ServiceFieldAnswerInput {
	singleText: [ServiceSingleAnswerFieldInput!]
	multilineText: [ServiceSingleAnswerFieldInput!]
	date: [ServiceSingleAnswerFieldInput!]
	number: [ServiceSingleAnswerFieldInput!]
	singleChoice: [ServiceSingleAnswerFieldInput!]

	# Multiple text fields
	multiText: [ServiceMultiAnswerFieldInput!]
	# Multiple choice fields (checkbox)
	multiChoice: [ServiceMultiAnswerFieldInput!]
}

type ServiceAnswers {
	id: String!
	contacts: [Contact!]!
	fieldAnswers: ServiceFieldAnswer!
}

type Service {
	id: String!
	orgId: String!
	name: String!
	description: String
	tags: [Tag!]!
	customFields: [ServiceCustomField!]!
	serviceStatus: ServiceStatus!
	contactFormEnabled: Boolean!
	answers: [ServiceAnswers!]!
}

input ServiceCustomFieldInput {
	fieldName: String!
	fieldType: String!
	fieldRequirements: String!
	fieldValue: [String!]
}

input ServiceAnswerInput {
	serviceId: String
	contacts: [String!]
	fieldAnswers: ServiceFieldAnswerInput!
}

input ServiceInput {
	serviceId: String
	orgId: String!
	name: String!
	description: String
	tags: [String!]
	customFields: [ServiceCustomFieldInput!]
	serviceStatus: ServiceStatus!
	contactFormEnabled: Boolean!
}

type ServiceResponse {
	status: StatusType!
	message: String
	service: Service
}
